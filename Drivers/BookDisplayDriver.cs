using System.Threading.Tasks;
using Lombiq.TrainingDemo.Models;
using Lombiq.TrainingDemo.ViewModels;
using OrchardCore.DisplayManagement.Handlers;
using OrchardCore.DisplayManagement.ModelBinding;
using OrchardCore.DisplayManagement.Views;

namespace Lombiq.TrainingDemo.Drivers
{
    // DisplayDrivers are for implementing the functionality for specific shapes generated by the DisplayManager. You
    // can create a driver for any object (persisted or not-persisted) where you can implement their specific logic for
    // generating reusable shapes. In case of an editor shape the model update and custom validation is also done in
    // these drivers. Finally, you can create multiple drivers for one object and the DisplayDriver will make sure that
    // all of your drivers are used and their specific logic will be executed.
    public class BookDisplayDriver : DisplayDriver<Book>
    {
        // So we have a Book object and we want to register some display shapes. For this you need to override the
        // Display or DisplayAsync methods depending on your code (only one can be used!). Ultimately, the
        // DisplayManager will return a shape that contains all (or some) of these shapes.
        public override IDisplayResult Display(Book model) =>
            // For the sake of demonstration we use Combined() here. It makes it possible to return multiple shapes
            // from a driver method - won't necessarily be displayed all at once!
            Combine(
                // Here we define a shape for the Title. It's not necessary to split these to atomic pieces but it
                // would make sense to make a reusable shape for the title. In the Location helper you define a
                // position for the shape. "Header" means that it will be displayed in the Header zone. "1" means that
                // it will be the first in the Header zone. Soon you will see what the zones are.
                View("Book_Display_Title", model)
                    .Location("Header: 1"),
                // Same applies here. This shape will be displayed in the Header zone too but in the second position.
                View("Book_Display_Author", model)
                    .Location("Header: 2"),
                // Create a separate shape for the cover photo. This will go to a different zone, the "Cover" zone.
                View("Book_Display_Cover", model)
                    .Location("Cover: 1"),
                // The shape for the description will be the first in the Content zone. Although, you can see another
                // parameter here, this is the display type. It is used to differentiate circumstances of displaying a
                // shape. Let's say you want to display Title, Author and Cover all the time (no shape type parameter),
                // but the description will be displayed only if the display type is "Description". You'll see an
                // example for that.
                View("Book_Display_Description", model)
                    .Location("Description", "Content: 1"));

        // Now let's see what those zones are and slowly clarify all these things you've seen above!
        // NEXT STATION: Views/Book.cshtml.

        public override IDisplayResult Edit(Book book) =>
            Initialize<BookViewModel>("Book_Edit", model =>
                {
                    model.Author = book.Author;
                    model.Title = book.Title;
                    model.Description = book.Description;
                });

        public override async Task<IDisplayResult> UpdateAsync(Book book, IUpdateModel updater)
        {
            var viewModel = new BookViewModel();

            await updater.TryUpdateModelAsync(viewModel, Prefix);

            book.Title = viewModel.Title;
            book.Author = viewModel.Author;
            book.Description = viewModel.Description;

            return Edit(book);
        }
    }
}